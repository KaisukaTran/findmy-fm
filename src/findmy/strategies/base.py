"""Base strategy class for FINDMY trading strategies."""

from abc import ABC, abstractmethod
from dataclasses import dataclass
from datetime import datetime
from typing import Optional, List, Dict, Any


@dataclass
class Signal:
    """
    Trading signal generated by a strategy.
    
    Attributes:
        symbol: Asset symbol (e.g., "BTC", "ETH")
        signal_type: Type of signal ("BUY", "SELL", "HOLD")
        timestamp: When the signal was generated
        confidence: Confidence level (0.0 to 1.0)
        price: Price at which signal was generated
        additional_data: Extra context (stop loss, take profit, etc.)
    """
    
    symbol: str
    signal_type: str  # "BUY", "SELL", "HOLD"
    timestamp: datetime
    confidence: float  # 0.0 to 1.0
    price: float
    additional_data: Dict[str, Any] = None
    
    def __post_init__(self):
        """Validate signal."""
        if self.signal_type not in ("BUY", "SELL", "HOLD"):
            raise ValueError(f"Invalid signal_type: {self.signal_type}")
        if not 0.0 <= self.confidence <= 1.0:
            raise ValueError(f"Confidence must be between 0.0 and 1.0, got {self.confidence}")
        if self.additional_data is None:
            self.additional_data = {}


class Strategy(ABC):
    """
    Abstract base class for trading strategies.
    
    Subclasses must implement the generate_signals method to produce trading signals
    based on market data and internal logic.
    """
    
    def __init__(self, name: str, symbols: List[str], config: Dict[str, Any] = None):
        """
        Initialize strategy.
        
        Args:
            name: Human-readable strategy name (e.g., "Moving Average Crossover")
            symbols: List of symbols to trade (e.g., ["BTC", "ETH"])
            config: Optional configuration dictionary for strategy parameters
        """
        self.name = name
        self.symbols = symbols
        self.config = config or {}
        self.last_signals: Dict[str, Signal] = {}  # Cache of last generated signals
        
    @abstractmethod
    def generate_signals(
        self,
        market_data: Dict[str, List[Dict[str, Any]]],
        current_prices: Dict[str, float],
    ) -> List[Signal]:
        """
        Generate trading signals based on market data.
        
        This method must be implemented by subclasses to define the strategy logic.
        
        Args:
            market_data: Dictionary mapping symbol to list of OHLCV candles
                        Format: {
                            "BTC": [
                                {"timestamp": ms, "open": float, "high": float, 
                                 "low": float, "close": float, "volume": float},
                                ...
                            ],
                            "ETH": [...],
                        }
            current_prices: Dictionary mapping symbol to current price
                           Format: {"BTC": 87972.0, "ETH": 2984.34}
        
        Returns:
            List of Signal objects with buy/sell/hold recommendations
        
        Example:
            >>> def generate_signals(self, market_data, current_prices):
            ...     signals = []
            ...     for symbol in self.symbols:
            ...         candles = market_data.get(symbol, [])
            ...         if len(candles) < 2:
            ...             continue
            ...         current = candles[-1]["close"]
            ...         previous = candles[-2]["close"]
            ...         signal_type = "BUY" if current > previous else "SELL"
            ...         signals.append(Signal(
            ...             symbol=symbol,
            ...             signal_type=signal_type,
            ...             timestamp=datetime.now(),
            ...             confidence=0.7,
            ...             price=current_prices[symbol]
            ...         ))
            ...     return signals
        """
        pass
    
    def validate_market_data(self, market_data: Dict[str, List[Dict[str, Any]]]) -> bool:
        """
        Validate that market data has required structure.
        
        Args:
            market_data: Market data dictionary to validate
        
        Returns:
            True if valid, False otherwise
        """
        if not isinstance(market_data, dict):
            return False
        
        for symbol, candles in market_data.items():
            if not isinstance(candles, list) or len(candles) == 0:
                return False
            
            # Check first candle has required fields
            first_candle = candles[0]
            required_fields = {"timestamp", "open", "high", "low", "close", "volume"}
            if not all(field in first_candle for field in required_fields):
                return False
        
        return True
    
    def cache_signals(self, signals: List[Signal]) -> None:
        """Cache the last generated signals for quick reference."""
        for signal in signals:
            self.last_signals[signal.symbol] = signal
    
    def get_last_signal(self, symbol: str) -> Optional[Signal]:
        """Get the last cached signal for a symbol."""
        return self.last_signals.get(symbol)
    
    def __repr__(self) -> str:
        """String representation of strategy."""
        return f"{self.__class__.__name__}(name='{self.name}', symbols={self.symbols})"
